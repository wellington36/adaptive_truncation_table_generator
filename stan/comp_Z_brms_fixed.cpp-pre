// Code generated by stanc v2.34.0
#include <stan/model/model_header.hpp>
namespace comp_Z_brms_fixed_model_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 85> locations_array__ =
  {" (found before start of program)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 6, column 4 to column 34)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 7, column 4 to column 20)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 9, column 4 to line 13, column 6)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 14, column 4 to line 15, column 62)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 5, column 54 to line 16, column 3)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 24, column 4 to column 15)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 25, column 4 to column 14)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 26, column 4 to column 20)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 27, column 4 to column 22)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 28, column 4 to column 23)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 30, column 6 to column 25)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 29, column 17 to line 31, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 29, column 4 to line 31, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 34, column 6 to column 36)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 33, column 17 to line 35, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 33, column 4 to line 35, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 37, column 6 to column 34)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 36, column 35 to line 38, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 36, column 4 to line 38, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 40, column 6 to column 50)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 39, column 55 to line 41, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 39, column 4 to line 41, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 45, column 6 to column 41)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 44, column 51 to line 46, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 44, column 4 to line 46, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 48, column 4 to column 35)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 51, column 13 to column 26)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 51, column 6 to column 40)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 52, column 6 to column 16)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 53, column 6 to column 29)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 55, column 8 to column 63)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 56, column 8 to column 15)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 58, column 10 to column 24)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 59, column 10 to column 16)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 57, column 41 to line 60, column 9)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 57, column 8 to line 60, column 9)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 61, column 8 to column 15)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 54, column 29 to line 62, column 7)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 54, column 6 to line 62, column 7)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 63, column 6 to column 46)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 49, column 27 to line 64, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 49, column 4 to line 64, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 65, column 4 to column 17)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 23, column 47 to line 66, column 3)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 73, column 17 to column 53)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 73, column 4 to column 53)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 74, column 4 to column 77)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 72, column 57 to line 75, column 3)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 78, column 17 to column 45)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 78, column 4 to column 45)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 79, column 4 to column 49)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 77, column 49 to line 80, column 3)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 83, column 4 to column 16)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 84, column 4 to column 15)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 85, column 11 to column 12)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 85, column 4 to column 28)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 87, column 6 to column 34)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 86, column 17 to line 88, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 86, column 4 to line 88, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 91, column 6 to column 36)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 90, column 17 to line 92, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 90, column 4 to line 92, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 94, column 6 to column 34)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 93, column 35 to line 95, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 93, column 4 to line 95, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 97, column 6 to column 40)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 96, column 19 to line 98, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 96, column 4 to line 98, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 99, column 4 to column 21)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 102, column 6 to column 15)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 100, column 52 to line 103, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 100, column 4 to line 103, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 104, column 4 to column 42)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 106, column 6 to column 20)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 105, column 16 to line 107, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 105, column 4 to line 107, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 109, column 4 to column 46)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 112, column 6 to column 59)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 111, column 19 to line 113, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 111, column 4 to line 113, column 5)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 114, column 4 to column 46)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 82, column 49 to line 115, column 3)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 118, column 4 to column 51)",
  " (in '/home/wellington/Documents/adaptive_truncation_table_generator/stan/comp_Z_brms_fixed.stan', line 117, column 50 to line 119, column 3)"};
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
log_Z_com_poisson_approx(const T0__& log_mu, const T1__& nu, std::ostream*
                         pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>* = nullptr>
stan::promote_args_t<T0__, T1__>
log_Z_com_poisson(const T0__& log_mu, const T1__& nu, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
stan::promote_args_t<T1__, T2__>
com_poisson_log_lpmf(const T0__& y, const T1__& log_mu, const T2__& nu,
                     std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
stan::promote_args_t<T1__, T2__>
com_poisson_lpmf(const T0__& y, const T1__& mu, const T2__& nu, std::ostream*
                 pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
stan::promote_args_t<T1__, T2__>
com_poisson_lcdf(const T0__& y, const T1__& mu, const T2__& nu, std::ostream*
                 pstream__);
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>* = nullptr>
stan::promote_args_t<T1__, T2__>
com_poisson_lccdf(const T0__& y, const T1__& mu, const T2__& nu,
                  std::ostream* pstream__);
// real log_Z_com_poisson_approx(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
log_Z_com_poisson_approx(const T0__& log_mu, const T1__& nu, std::ostream*
                         pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ nu_mu = DUMMY_VAR__;
    current_statement__ = 1;
    nu_mu = (nu * stan::math::exp(log_mu));
    local_scalar_t__ nu2 = DUMMY_VAR__;
    current_statement__ = 2;
    nu2 = stan::math::pow(nu, 2);
    local_scalar_t__ log_sum_resid = DUMMY_VAR__;
    current_statement__ = 3;
    log_sum_resid = stan::math::log1p(((((stan::math::pow(nu_mu, -(1)) * (nu2
                      - 1)) / 24) + (((stan::math::pow(nu_mu, -(2)) * (nu2 -
                      1)) / 1152) * (nu2 + 23))) +
                      (((stan::math::pow(nu_mu, -(3)) * (nu2 - 1)) / 414720)
                      * (((5 * stan::math::pow(nu2, 2)) - (298 * nu2)) +
                      11237))));
    current_statement__ = 4;
    return ((nu_mu + log_sum_resid) -
           ((((stan::math::log((2 * stan::math::pi())) + log_mu) * (nu - 1))
           / 2) + (stan::math::log(nu) / 2)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real log_Z_com_poisson(real, real)
template <typename T0__, typename T1__,
          stan::require_all_t<stan::math::disjunction<stan::is_autodiff<T0__>,
                                                      std::is_floating_point<T0__>>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>>*>
stan::promote_args_t<T0__, T1__>
log_Z_com_poisson(const T0__& log_mu, const T1__& nu, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ log_Z = DUMMY_VAR__;
    int k = std::numeric_limits<int>::min();
    current_statement__ = 7;
    k = 2;
    int M = std::numeric_limits<int>::min();
    current_statement__ = 8;
    M = 1000000;
    int converged = std::numeric_limits<int>::min();
    current_statement__ = 9;
    converged = 0;
    int num_terms = std::numeric_limits<int>::min();
    current_statement__ = 10;
    num_terms = 50;
    current_statement__ = 13;
    if (stan::math::logical_eq(nu, 1)) {
      current_statement__ = 11;
      return stan::math::exp(log_mu);
    }
    current_statement__ = 16;
    if (stan::math::logical_lte(nu, 0)) {
      current_statement__ = 14;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "nu must be positive");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 19;
    if (stan::math::logical_eq(nu, stan::math::positive_infinity())) {
      current_statement__ = 17;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "nu must be finite");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 22;
    if ((stan::math::primitive_value(
           stan::math::logical_gte((log_mu * nu), stan::math::log(1.5)))
        &&
        stan::math::primitive_value(
          stan::math::logical_gte(log_mu, stan::math::log(1.5))))) {
      current_statement__ = 20;
      return log_Z_com_poisson_approx(log_mu, nu, pstream__);
    }
    current_statement__ = 25;
    if (stan::math::logical_gt((nu * ((M * log_mu) -
          stan::math::lgamma((M + 1)))), -(36.0))) {
      current_statement__ = 23;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "nu is too close to zero.");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 26;
    log_Z = stan::math::log1p_exp((nu * log_mu));
    current_statement__ = 42;
    while (stan::math::logical_eq(converged, 0)) {
      current_statement__ = 27;
      stan::math::validate_non_negative_index("log_Z_terms", "num_terms + 1",
        (num_terms + 1));
      Eigen::Matrix<local_scalar_t__,-1,1> log_Z_terms =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant((num_terms + 1),
          DUMMY_VAR__);
      int i = std::numeric_limits<int>::min();
      current_statement__ = 29;
      i = 1;
      current_statement__ = 30;
      stan::model::assign(log_Z_terms, log_Z,
        "assigning variable log_Z_terms", stan::model::index_uni(1));
      current_statement__ = 39;
      while (stan::math::logical_lte(i, num_terms)) {
        current_statement__ = 31;
        stan::model::assign(log_Z_terms, (nu * ((k * log_mu) -
          stan::math::lgamma((k + 1)))), "assigning variable log_Z_terms",
          stan::model::index_uni((i + 1)));
        current_statement__ = 32;
        k = (k + 1);
        current_statement__ = 36;
        if (stan::math::logical_lte(
              stan::model::rvalue(log_Z_terms, "log_Z_terms",
                stan::model::index_uni((i + 1))), -(36.0))) {
          current_statement__ = 33;
          converged = 1;
          break;
        }
        current_statement__ = 37;
        i = (i + 1);
      }
      current_statement__ = 40;
      log_Z = stan::math::log_sum_exp(
                stan::model::rvalue(log_Z_terms, "log_Z_terms",
                  stan::model::index_min_max(1, i)));
    }
    current_statement__ = 43;
    return log_Z;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real com_poisson_log_lpmf(int, real, real)
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
stan::promote_args_t<T1__, T2__>
com_poisson_log_lpmf(const T0__& y, const T1__& log_mu, const T2__& nu,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__, T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 46;
    if (stan::math::logical_eq(nu, 1)) {
      current_statement__ = 45;
      return stan::math::poisson_log_lpmf<false>(y, log_mu);
    }
    current_statement__ = 47;
    return ((nu * ((y * log_mu) - stan::math::lgamma((y + 1)))) -
           log_Z_com_poisson(log_mu, nu, pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real com_poisson_lpmf(int, real, real)
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
stan::promote_args_t<T1__, T2__>
com_poisson_lpmf(const T0__& y, const T1__& mu, const T2__& nu, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__, T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 50;
    if (stan::math::logical_eq(nu, 1)) {
      current_statement__ = 49;
      return stan::math::poisson_lpmf<false>(y, mu);
    }
    current_statement__ = 51;
    return com_poisson_log_lpmf<false>(y, stan::math::log(mu), nu, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real com_poisson_lcdf(int, real, real)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
stan::promote_args_t<T1__, T2__>
com_poisson_lcdf(const T0__& y, const T1__& mu, const T2__& nu, std::ostream*
                 pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__, T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ log_mu = DUMMY_VAR__;
    local_scalar_t__ log_Z = DUMMY_VAR__;
    current_statement__ = 55;
    stan::math::validate_non_negative_index("log_num_terms", "y", y);
    Eigen::Matrix<local_scalar_t__,-1,1> log_num_terms =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(y, DUMMY_VAR__);
    current_statement__ = 59;
    if (stan::math::logical_eq(nu, 1)) {
      current_statement__ = 57;
      return stan::math::poisson_lcdf(y, mu);
    }
    current_statement__ = 62;
    if (stan::math::logical_lte(nu, 0)) {
      current_statement__ = 60;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "nu must be positive");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 65;
    if (stan::math::logical_eq(nu, stan::math::positive_infinity())) {
      current_statement__ = 63;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "nu must be finite");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 68;
    if (stan::math::logical_gt(y, 10000)) {
      current_statement__ = 66;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__, "cannot handle y > 10000");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 69;
    log_mu = stan::math::log(mu);
    current_statement__ = 72;
    if (stan::math::logical_lte((nu * ((y * log_mu) -
          stan::math::lgamma((y + 1)))), -(36.0))) {
      current_statement__ = 70;
      return 0;
    }
    current_statement__ = 73;
    log_Z = log_Z_com_poisson(log_mu, nu, pstream__);
    current_statement__ = 76;
    if (stan::math::logical_eq(y, 0)) {
      current_statement__ = 74;
      return -(log_Z);
    }
    current_statement__ = 77;
    stan::model::assign(log_num_terms, stan::math::log1p_exp((nu * log_mu)),
      "assigning variable log_num_terms", stan::model::index_uni(1));
    current_statement__ = 80;
    for (int k = 2; k <= y; ++k) {
      current_statement__ = 78;
      stan::model::assign(log_num_terms, (nu * ((k * log_mu) -
        stan::math::lgamma((k + 1)))), "assigning variable log_num_terms",
        stan::model::index_uni(k));
    }
    current_statement__ = 81;
    return (stan::math::log_sum_exp(log_num_terms) - log_Z);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
// real com_poisson_lccdf(int, real, real)
template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<std::is_integral<T0__>,
                              stan::math::disjunction<stan::is_autodiff<T1__>,
                                                      std::is_floating_point<T1__>>,
                              stan::math::disjunction<stan::is_autodiff<T2__>,
                                                      std::is_floating_point<T2__>>>*>
stan::promote_args_t<T1__, T2__>
com_poisson_lccdf(const T0__& y, const T1__& mu, const T2__& nu,
                  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T1__, T2__>;
  int current_statement__ = 0;
  // suppress unused var warning
  (void) current_statement__;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 83;
    return stan::math::log1m_exp(com_poisson_lcdf(y, mu, nu, pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[stan::function]]
double
log_Z_com_poisson_approx(const double& log_mu, const double& nu,
                         std::ostream* pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::log_Z_com_poisson_approx(log_mu,
           nu, pstream__);
}
// [[stan::function]]
double
log_Z_com_poisson(const double& log_mu, const double& nu, std::ostream*
                  pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::log_Z_com_poisson(log_mu, nu,
           pstream__);
}
// [[stan::function]]
double
com_poisson_log_lpmf(const int& y, const double& log_mu, const double& nu,
                     std::ostream* pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::com_poisson_log_lpmf<false>(y,
           log_mu, nu, pstream__);
}
// [[stan::function]]
double
com_poisson_lpmf(const int& y, const double& mu, const double& nu,
                 std::ostream* pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::com_poisson_lpmf<false>(y, mu,
           nu, pstream__);
}
// [[stan::function]]
double
com_poisson_lcdf(const int& y, const double& mu, const double& nu,
                 std::ostream* pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::com_poisson_lcdf(y, mu, nu,
           pstream__);
}
// [[stan::function]]
double
com_poisson_lccdf(const int& y, const double& mu, const double& nu,
                  std::ostream* pstream__ = nullptr) {
  return comp_Z_brms_fixed_model_namespace::com_poisson_lccdf(y, mu, nu,
           pstream__);
}